<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>walytis_beta_api.blockchain_model API documentation</title>
<meta name="description" content="`walytis_beta_api` Blockchain class …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{color:#ddd;background:#111;--highlight-color:#050}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #222;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#f33}pre code{color:#ddd;background:#080808;font-size:.8em;line-height:1.4em}code{color:#ddd;background:#141414;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{color:#ddd;background:#080808;border:0;border-top:1px solid #555;border-bottom:1px solid #555;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #222}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{color:#ddd;background:#181818;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{color:#ddd;background:#181818}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#666;border-left:5px solid #181818;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#999;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{color:#ddd;background:#202}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #222}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#fff !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #666;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>walytis_beta_api.blockchain_model</code></h1>
</header>
<section id="section-intro">
<p><code><a title="walytis_beta_api" href="index.html">walytis_beta_api</a></code> Blockchain class.</p>
<p>The herein contained Blockchain class isn't the code running the Walytis
blockchains themselves, it is merely a construct in <code>wlaytis_beta_api</code> for
providing the means to interact with a Walytis blockchain.</p>
<p>The real blockchain class for running blockchains in Walytis-Core is in:
Brenthy/blockchains/Walytis_Beta/walytis_beta.py</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;`walytis_beta_api` Blockchain class.

The herein contained Blockchain class isn&#39;t the code running the Walytis
blockchains themselves, it is merely a construct in `wlaytis_beta_api` for
providing the means to interact with a Walytis blockchain.

The real blockchain class for running blockchains in Walytis-Core is in:
Brenthy/blockchains/Walytis_Beta/walytis_beta.py
&#34;&#34;&#34;

import os
import shutil
from threading import Lock, Thread
from typing import Callable

import appdirs
from walytis_beta_tools.log import logger_blockchain_model as logger
from brenthy_tools_beta.utils import (
    bytes_to_string,
    function_name,
    string_to_bytes,
)

from walytis_beta_tools._experimental.block_lazy_loading import BlocksList, BlockLazilyLoaded
from walytis_beta_tools.block_model import Block, short_from_long_id
from walytis_beta_tools.exceptions import (  # pylint: disable=unused-import
    BlockCreationError,
    BlockNotFoundError,
    NotSupposedToHappenError,
)
from ._experimental.generic_blockchain import _GenericBlockchainImpl as GenericBlockchain
from .walytis_beta_interface import (
    WALYTIS_BETA,
    BlocksListener,
    create_block,
    create_blockchain,
    create_invitation,
    delete_blockchain,
    delete_invitation,
    get_block,
    get_blockchain_data,
    get_blockchain_id,
    get_blockchain_name,
    get_invitations,
    get_latest_blocks,
    get_peers,
    join_blockchain,
)
from collections.abc import Generator
from walytis_beta_tools._experimental.generic_block import GenericBlock
from time import sleep

N_STARTUP_BLOCKS = (
    400  # how many of this blockchain&#39;s  blocks we should load on startup
)
# logger.set_print_level(&#34;info&#34;)


walytis_beta_appdata_dir = os.path.join(appdirs.user_data_dir(), &#34;WalytisApps&#34;)

def set_appdata_dir(appdata_dir: str) -&gt; None:
    &#34;&#34;&#34;Set the appdata directory for keeping track of apps&#39; Walytis usage.&#34;&#34;&#34;
    global walytis_beta_appdata_dir
    walytis_beta_appdata_dir = appdata_dir
    if not os.path.exists(walytis_beta_appdata_dir):
        os.makedirs(walytis_beta_appdata_dir)

def get_appdata_dir() -&gt; str:
    &#34;&#34;&#34;Get the appdata directory for keeping track of apps&#39; Walytis usage.&#34;&#34;&#34;
    return walytis_beta_appdata_dir
    
# backward-compatibility with old path:
_old_appdata_path = os.path.join(appdirs.user_data_dir(), &#34;BrenthyApps&#34;)
if os.path.exists(_old_appdata_path):
    walytis_beta_appdata_dir = _old_appdata_path

# backkward-compatibility with old function name
def get_walytis_appdata_dir() -&gt; str:
    &#34;&#34;&#34;Get the appdata directory for keeping track of apps&#39; Walytis usage.
    
    Exactly the same as get_appdata_dir(), kept for backward-compatibility.
    &#34;&#34;&#34;
    print(&#34;DEPRECATING: please use `get_appdata_dir()` instead.&#34;)
    return get_appdata_dir()


class Blockchain(GenericBlockchain):
    &#34;&#34;&#34;Represents a running Walytis_Beta blockchain.

    Provides the means to interact with a Walytis blockchain.
    &#34;&#34;&#34;

    def __init__(
        self,
        blockchain_id: str,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ):
        &#34;&#34;&#34;Create an object to represent a Walytis blockchain.

        Args:
            blockchain_id (str): the id or name of the blockchain
            block_received_handler (Callable): function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this eventhandler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received
        &#34;&#34;&#34;
        # declare attribute already to avoid error in destructor
        # if error occurs in constructor
        self._blocks_listener = None
        self._blocks = BlocksList(BlockLazilyLoaded)

        self.blockchain_id = get_blockchain_id(blockchain_id)
        self.name = get_blockchain_name(self.blockchain_id)
        self.app_name = app_name
        self._block_received_handler = block_received_handler
        self._block_received_handler_lock = Lock()

        if not isinstance(blockchain_id, str):
            error = TypeError(
                &#34;The blockchain_id parameter must be of type string.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        if appdata_dir and app_name:
            error = ValueError(
                &#34;Don&#39;t pass both app_name and appdata_dir. &#34;
                &#34;You can pass one of them or none.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error

        if not isinstance(app_name, str):
            error = TypeError(&#34;The app_name parameter must be of type string.&#34;)
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        if not isinstance(appdata_dir, str):
            error = TypeError(
                &#34;The appdata_dir parameter must be of type string.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        if appdata_dir and not os.path.isdir(appdata_dir):
            _error = FileNotFoundError(
                &#34;The appdata_dir parameter must be an exising directory.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(_error)}&#34;)
            raise _error

        self._blocklist_lock = Lock()
        self._terminate = False

        self.sequential_block_handling = sequential_block_handling
        self.update_blockids_before_handling = update_blockids_before_handling

        self._blocks_listener = BlocksListener(
            self.blockchain_id, self._on_new_block_received
        )

        # if the user specified an appdata directory, use it
        if appdata_dir:
            self.appdata_dir = appdata_dir
        elif app_name:
            self.appdata_dir = os.path.join(
                walytis_beta_appdata_dir,
                self.blockchain_id,
                &#34;Apps&#34;,
                self.app_name,
            )
            # if appdata path doesn&#39;t exist
            # and we&#39;re not being used by a temporary app
            if not os.path.exists(self.appdata_dir):
                os.makedirs(self.appdata_dir)
        else:
            self.appdata_dir = &#34;&#34;
        if forget_appdata and os.path.exists(self.appdata_dir):
            shutil.rmtree(self.appdata_dir)
        self._load_blocks_list()
        if auto_load_missed_blocks:
            self.load_missed_blocks(N_STARTUP_BLOCKS)

    def add_block(
        self, content: bytearray | bytes, topics: list[str] | str | None = None,
        wait_until_handled: bool = True
    ) -&gt; Block:
        &#34;&#34;&#34;Add a new block to this blockchain.

        Args:
            content (bytearay): the content which the new block should have
            topics (list&lt;str&gt;): a list of topics this block belongs to
                    Topics allow blocks to be categorised by their application-
                    level function given the block ID only, without reading the
                    block content
        Returns:
            Block block: the newly created block
        &#34;&#34;&#34;
        if type(content) not in [bytearray, bytes]:
            raise TypeError(
                &#34;Content must be of type bytes or bytearray, not &#34;
                f&#34;{type(content)}&#34;
            )
        self._blocklist_lock.acquire()

        if topics == []:
            topics = self.blockchain_id
        try:
            block = create_block(self.blockchain_id, content, topics=topics)
        except BlockCreationError as error:
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            self._blocklist_lock.release()
            raise error

        # self._blocks.add_block_id(block.long_id)
        # self._save_blocks_list(True)
        self._blocklist_lock.release()
        if wait_until_handled:
            self._on_new_block_received(block)

            # wait for block received handler to finish for consistent behaviour
            while block.long_id not in self.get_block_ids():
                sleep(0.1)
                if self._terminate:
                    self._on_new_block_received(block, override_terminate=True)
                    break

        return block

    def get_blocks(self, reverse: bool = False) -&gt; Generator[BlockLazilyLoaded]:
        return self._blocks.get_blocks(reverse=reverse)

    def get_block_ids(self) -&gt; list[bytes]:
        return self._blocks.get_long_ids()

    def get_num_blocks(self) -&gt; int:
        return len(self._blocks)

    def has_block_id(self, block_id: bytes | bytearray) -&gt; bool:
        if isinstance(block_id, bytearray):
            block_id = bytes(block_id)
        return block_id in self._blocks

    def has_block(self, block: GenericBlock) -&gt; bool:
        return self.has_block_id(block.long_id)

    def get_block(self, id: bytearray | bytes) -&gt; Block:
        &#34;&#34;&#34;Get a block object from this blockchain given its block ID.

        Args:
            id (bytearray): the id of the block to look up
                            or if int: the index of the block to look up
        Returns:
            Block: a Block object containing all the requested block&#39;s data
        &#34;&#34;&#34;
        self._blocklist_lock.acquire()

        # if index is passed instead of block_id, get block_id from index
        if isinstance(id, int):
            try:
                id = self.get_block_ids()[id]
            except IndexError:
                self._blocklist_lock.release()
                message = (
                    &#34;Walytis_BetaAPI.Blockchain: Get Block from index: &#34;
                    &#34;Index out of range.&#34;
                )
                logger.error(message)
                raise IndexError(message)
        else:
            id_bytearray = bytearray(id)
            len_id = len(id_bytearray)
            if bytearray([0, 0, 0, 0]) not in id_bytearray:  # if a short ID was passed
                short_id = None
                for long_id in self.get_block_ids():
                    if bytearray(long_id)[:len_id] == id_bytearray:
                        short_id = long_id
                        break
                if not short_id:
                    raise BlockNotFoundError()
                id = bytes(short_id)
        if isinstance(id, bytearray):
            id = bytes(id)
        try:
            block = self._blocks[id]
            self._blocklist_lock.release()
            return block
        except KeyError:
            self._blocklist_lock.release()

            error = BlockNotFoundError(
                &#34;This block isn&#39;t recorded (by brenthy_api.Blockchain) as being &#34;
                &#34;part of this blockchain.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error

    def create_invitation(
        self, one_time: bool = True, shared: bool = False
    ) -&gt; str:
        &#34;&#34;&#34;Create a code which another node can use to join this blockchain.

        Args:
            one_time (bool): whether this code is non-reusable
            shared (bool): whether this invitation should be hosted by other
                    nodes who join this blockchain too, or just by this one
        Returns:
            str: a code that can be used by other nodes to join this blockchain
        &#34;&#34;&#34;
        return create_invitation(
            self.blockchain_id, one_time=one_time, shared=shared
        )

    def delete_invitation(self, invitation: str) -&gt; None:
        &#34;&#34;&#34;Delete an invitation from this blockchain.

        Args:
            invitation (str): the invitation to delete
        &#34;&#34;&#34;
        delete_invitation(self.blockchain_id, invitation)

    def get_invitations(self) -&gt; list[str]:
        &#34;&#34;&#34;Get a list of the invitations we&#39;re hositng for this blockchain.

        Returns:
            list: the invitations we&#39;re hosting for this blockchain,
                    as JSON strings
        &#34;&#34;&#34;
        return get_invitations(self.blockchain_id)

    def get_peers(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the IPFS peer IDs of blockchain nodes who are currently online.

        Returns:
            list[str]: a list of IPFS peer IDs of the currently connected nodes
        &#34;&#34;&#34;
        return get_peers(self.blockchain_id)

    def get_blockchain_data(self) -&gt; str:
        &#34;&#34;&#34;Create a zip file of all this blockchain&#39;s data, returning its path.

        Returns:
            str: the path of the zip file created
        &#34;&#34;&#34;
        return get_blockchain_data(self.blockchain_id)

    def _run_block_received_handler(self, block: Block) -&gt; None:
        if not self.block_received_handler:
            return
        return_value = self.block_received_handler(block)
        if return_value is not None:
            raise ValueError(
                &#34;block_received_handler must return None, as it&#39;s meaningful &#34;
                &#34;usage is reserved for future use&#34;
            )

    def _on_new_block_received(
        self,
        block: Block,
        save_blocks_list: bool = True,
        already_locked: bool = False,
        override_terminate: bool = False,
        already_locked_block_received: bool = False,

    ) -&gt; None:
        &#34;&#34;&#34;Handle a newly received block.

        Gets called when this blockchain received a new block. Saves the block
        in our block list and calls the appropriate user-defined eventhandlers.

        Args:
            block (Block): the newly received block
            save_blocks_list (bool): whether or not to save our updated list
                        of blocks to appdata
            already_locked (bool): whether or not we&#39;ve already acquired the
                        lock for working with the blocks list
            override_terminate (bool): whether to process block even if this
                        Blockchain object is terminating
        &#34;&#34;&#34;
        if self._terminate and not override_terminate:
            return
        if not already_locked_block_received:
            self._block_received_handler_lock.acquire()
        # if not already_locked:
        #     self._blocklist_lock.acquire()
        short_ids = self._blocks.get_short_ids()
        if bytes(block.long_id) not in self._blocks:
            for parent in block.parents:
                if bytes(parent) not in short_ids:
                    self._on_new_block_received(
                        get_block(self.blockchain_id, parent),
                        save_blocks_list=save_blocks_list,
                        # already_locked=True
                        already_locked=already_locked,
                        already_locked_block_received=True
                    )
            try:
                if self.update_blockids_before_handling:
                    self._update_blocks_list(block, already_locked=True)

                # call user&#39;s block_received_handler
                # only if the block isn&#39;t a genesis block
                if block.topics == [&#34;genesis&#34;]:
                    logger.info(&#34;WAPI: Received Genesis Block!&#34;)
                elif self.block_received_handler:  # it&#39;s a normal block
                    if self.sequential_block_handling:
                        self._run_block_received_handler(block)
                    else:
                        Thread(
                            target=self._run_block_received_handler,
                            args=(block,),
                            name=f&#34;WAPI-{self.name}-block_received_handler&#34;,
                        ).start()
                if not self.update_blockids_before_handling:
                    self._update_blocks_list(block, already_locked=True)

            except Exception as e:
                logger.error(f&#34;WAPI: Blockchain._on_new_block_received: {e}&#34;)
        if not already_locked_block_received:
            self._block_received_handler_lock.release()

    def _update_blocks_list(
        self,
        block: Block,
        save_blocks_list: bool = True,
        already_locked: bool = False
    ) -&gt; None:
        if not already_locked:
            self._blocklist_lock.acquire()
        self._blocks.add_block_id(block.long_id)
        if save_blocks_list:
            self._save_blocks_list(already_locked=True)

        if not already_locked:
            self._blocklist_lock.release()

    def _save_blocks_list(self, already_locked: bool = False) -&gt; None:
        &#34;&#34;&#34;Save our list of known/processed block IDs to an appdata file.&#34;&#34;&#34;
        # don&#39;t save any appdata if we&#39;re being used by a temporary app
        if not self.appdata_dir:
            return
        if not already_locked:
            self._blocklist_lock.acquire()

        with open(
            os.path.join(self.appdata_dir, &#34;blocks_list&#34;), &#34;w+&#34;
        ) as filewriter:
            filewriter.writelines(
                [
                    bytes_to_string(block_id) + &#34;\n&#34;
                    for block_id in self.get_block_ids()
                ]
            )
        if not already_locked:
            self._blocklist_lock.release()

    def load_missed_blocks(self, amount: int) -&gt; None:
        &#34;&#34;&#34;Get recent blocks.

        Ask the Blockchain for recent blocks on this topic that might have been
        received while this program was offline. Any of these missed blocks
        will trigger the self.block_received_handler event handler.

        Args:
            amount (int): the number of blocks to load
        &#34;&#34;&#34;
        # self._blocklist_lock.acquire()
        logger.info(amount)
        latest_blocks = get_latest_blocks(
            self.blockchain_id, amount=amount, long_ids=True)
        if not latest_blocks:
            # self._blocklist_lock.release()
            error = NotSupposedToHappenError(
                &#34;Got no latest blocks from blockchain. &#34;
                &#34;This is probably due to a bug in walytis_api.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        count = 0
        for block_id in latest_blocks:
            if self._terminate:
                # self._blocklist_lock.release()
                return

            if bytes(block_id) not in self.get_block_ids():
                try:
                    block = get_block(self.blockchain_id, block_id)
                    self._on_new_block_received(
                        block,
                        save_blocks_list=False,
                        # already_locked=True
                    )
                except Exception as e:
                    logger.error(
                        f&#34; Blockchain.load_missed_blocks: {e}&#34;
                    )
            else:
                count += 1

        self._save_blocks_list(
            # already_locked=True
        )
        # self._blocklist_lock.release()

    def _load_blocks_list(self) -&gt; None:
        &#34;&#34;&#34;Load our list of known/processed block IDs from an appdata file.&#34;&#34;&#34;
        if not self.appdata_dir:
            return

        self._blocklist_lock.acquire()

        if os.path.exists(os.path.join(self.appdata_dir, &#34;blocks_list&#34;)):
            block_ids = []
            with open(
                os.path.join(self.appdata_dir, &#34;blocks_list&#34;), &#34;r&#34;
            ) as filereader:
                for line in filereader.readlines():
                    block_ids.append(string_to_bytes(line[:-1]))

            # AppData migration from storing short IDs to long_ids
            # for BACKWARDS COMPATIBILITY
            if bytearray([0, 0, 0, 0]) not in bytearray(block_ids[0]) or bytearray([0, 0, 0, 0]) not in bytearray(block_ids[-1]):
                print(&#34;Migrating...&#34;)
                block_long_ids = dict([
                    (bytes(short_from_long_id(long_id)), long_id)
                    for long_id in get_latest_blocks(self.blockchain_id, long_ids=True)
                ])
                block_ids = [block_long_ids[bytes(short_id)]
                             for short_id in block_ids]

            self._blocks = BlocksList.from_block_ids(
                block_ids, BlockLazilyLoaded)
        self._blocklist_lock.release()

    @property
    def block_ids(self) -&gt; list[bytearray]:
        &#34;&#34;&#34;Get a list of this blockchain&#39;s blocks&#39; short IDs.

        Retained for backwards-compatibilty.
        &#34;&#34;&#34;
        print(
            &#34;`Blockchain.block_ids` has been deprecated because it returns &#34;
            &#34;block&#39;s short IDs. Use `Blockchain.get_block_ids()` instead, &#34;
            &#34;which returns their long IDs.&#34;
        )
        return self._blocks.get_short_ids()

    def terminate(self) -&gt; None:
        &#34;&#34;&#34;Clean up all resources this object uses.&#34;&#34;&#34;
        self._terminate = True
        logger.debug(&#34;Terminating...&#34;)
        if self._blocks_listener:
            self._blocks_listener.terminate()
        logger.debug(&#34;Terminated!&#34;)

    def __del__(self) -&gt; None:
        &#34;&#34;&#34;Clean up all resources this object uses.&#34;&#34;&#34;
        self.terminate()

    def delete(self) -&gt; None:
        &#34;&#34;&#34;Stop our participation in this blockchain.

        Locally deletes all data we have stored for it.
        &#34;&#34;&#34;
        self.terminate()
        delete_blockchain(self.blockchain_id)

    @staticmethod
    def create(
        blockchain_name: str = &#34;&#34;,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ) -&gt; &#39;Blockchain&#39;:
        &#34;&#34;&#34;Create and run a new blockchain.

        Args:
            blockchain_name (str):
                blockchain&#39;s local name: a human-readable label
                to ease recognition when manually interacting with WalytisAPI.
                Note: A blockchain&#39;s name only exists in the scope of a single
                node, meaning it is not guaranteed to be globally unique.
                Applications should use a blockchain&#39;s ID (attribute &#39;id&#39;) as
                its identifier, not the blockchain_name.
            block_received_handler (Callable):
                A function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this handler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                    blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received

        Returns:
            Blockchain: a Blockchain object representing the created blockchain
        &#34;&#34;&#34;
        blockchain_id = create_blockchain(blockchain_name=blockchain_name)
        return Blockchain(
            blockchain_id,
            block_received_handler=block_received_handler,
            app_name=app_name,
            appdata_dir=appdata_dir,
            auto_load_missed_blocks=auto_load_missed_blocks,
            forget_appdata=forget_appdata,
            sequential_block_handling=sequential_block_handling,
            update_blockids_before_handling=update_blockids_before_handling,
        )

    @staticmethod
    def join(
        invitation: str,
        blockchain_name: str = &#34;&#34;,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ) -&gt; &#39;Blockchain&#39;:
        &#34;&#34;&#34;Join a blockchain using an invitation generated by another node.

        Args:
            invitation (str): the invitation generated by a blockchain member
            blockchain_name (str):
                blockchain&#39;s local name: a human-readable label
                to ease recognition when manually interacting with WalytisAPI.
                Note: A blockchain&#39;s name only exists in the scope of a single
                node, meaning it is not guaranteed to be globally unique.
                Applications should use a blockchain&#39;s ID (attribute &#39;id&#39;) as
                its identifier, not the blockchain_name.
            block_received_handler (Callable):
                A function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this handler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                    blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received

        Returns:
            Blockchain: a Blockchain object representing the joined blockchain
        &#34;&#34;&#34;
        blockchain_id = join_blockchain(
            invitation, blockchain_name=blockchain_name
        )
        return Blockchain(
            blockchain_id,
            block_received_handler=block_received_handler,
            app_name=app_name,
            appdata_dir=appdata_dir,
            auto_load_missed_blocks=auto_load_missed_blocks,
            forget_appdata=forget_appdata,
            sequential_block_handling=sequential_block_handling,
            update_blockids_before_handling=update_blockids_before_handling,
        )

    @staticmethod
    def from_blockchain_id(
        blockchain_id: str,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ) -&gt; &#39;Blockchain&#39;:
        &#34;&#34;&#34;Create an object to represent a Walytis blockchain.

        Args:
            blockchain_id (str): the id or name of the blockchain
            block_received_handler (Callable): function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this eventhandler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received
        &#34;&#34;&#34;
        return Blockchain(
            blockchain_id=blockchain_id,
            block_received_handler=block_received_handler,
            app_name=app_name,
            appdata_dir=appdata_dir,
            auto_load_missed_blocks=auto_load_missed_blocks,
            forget_appdata=forget_appdata,
            sequential_block_handling=sequential_block_handling,
            update_blockids_before_handling=update_blockids_before_handling,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="walytis_beta_api.blockchain_model.set_appdata_dir"><code class="name flex">
<span>def <span class="ident">set_appdata_dir</span></span>(<span>appdata_dir: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the appdata directory for keeping track of apps' Walytis usage.</p></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.get_appdata_dir"><code class="name flex">
<span>def <span class="ident">get_appdata_dir</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the appdata directory for keeping track of apps' Walytis usage.</p></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.get_walytis_appdata_dir"><code class="name flex">
<span>def <span class="ident">get_walytis_appdata_dir</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the appdata directory for keeping track of apps' Walytis usage.</p>
<p>Exactly the same as get_appdata_dir(), kept for backward-compatibility.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="walytis_beta_api.blockchain_model.Blockchain"><code class="flex name class">
<span>class <span class="ident">Blockchain</span></span>
<span>(</span><span>blockchain_id: str, block_received_handler: Optional[Callable[[walytis_beta_tools.block_model.Block], None]] = None, app_name: str = '', appdata_dir: str = '', auto_load_missed_blocks: bool = True, forget_appdata: bool = False, sequential_block_handling: bool = True, update_blockids_before_handling: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a running Walytis_Beta blockchain.</p>
<p>Provides the means to interact with a Walytis blockchain.</p>
<p>Create an object to represent a Walytis blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blockchain_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the id or name of the blockchain</dd>
<dt><strong><code>block_received_handler</code></strong> :&ensp;<code>Callable</code></dt>
<dd>function to be called every
time a new block is received on this blockchain.
This function should not have a long execution time because
this class waits for its execution to finish before saving
the received block in its list of processed blocks.
If this eventhandler raises an exception, it will be called
with the same block at a later stage.
The same block is never passed to this handler twice, and
no child block will ever be passed to this function before
its parent block.</dd>
<dt><strong><code>app_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the unique name of this application, to distinguish
between different applications that use the same blockchain
for appdata management</dd>
<dt><strong><code>appdata_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the directory in which to save data on which
blocks this application has processed for this blockchain</dd>
<dt><strong><code>auto_load_missed_blocks</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to automatically get
and process the blocks received by the blockchain while
this application was offline.</dd>
<dt><strong><code>forget_appdata</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to ignore and overwrite any
existing records of which blocks applications with the
providede <code>app_name</code> have processed</dd>
<dt><strong><code>sequential_block_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the provided block-
received handler will be executed on the main thread, and
the handler will only be executed for the next block
after the handler for the last block executes witout
error.
If set to False, the block-received handler will always be
started on a new thread, meaning it is possible for
multiple calls of the handler to be running in parallel
for different blocks.</dd>
<dt><strong><code>update_blockids_before_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not the
<code>blocks</code> attribute should be updated before running
<code>block_received_handler</code> when a new block is received</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blockchain(GenericBlockchain):
    &#34;&#34;&#34;Represents a running Walytis_Beta blockchain.

    Provides the means to interact with a Walytis blockchain.
    &#34;&#34;&#34;

    def __init__(
        self,
        blockchain_id: str,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ):
        &#34;&#34;&#34;Create an object to represent a Walytis blockchain.

        Args:
            blockchain_id (str): the id or name of the blockchain
            block_received_handler (Callable): function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this eventhandler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received
        &#34;&#34;&#34;
        # declare attribute already to avoid error in destructor
        # if error occurs in constructor
        self._blocks_listener = None
        self._blocks = BlocksList(BlockLazilyLoaded)

        self.blockchain_id = get_blockchain_id(blockchain_id)
        self.name = get_blockchain_name(self.blockchain_id)
        self.app_name = app_name
        self._block_received_handler = block_received_handler
        self._block_received_handler_lock = Lock()

        if not isinstance(blockchain_id, str):
            error = TypeError(
                &#34;The blockchain_id parameter must be of type string.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        if appdata_dir and app_name:
            error = ValueError(
                &#34;Don&#39;t pass both app_name and appdata_dir. &#34;
                &#34;You can pass one of them or none.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error

        if not isinstance(app_name, str):
            error = TypeError(&#34;The app_name parameter must be of type string.&#34;)
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        if not isinstance(appdata_dir, str):
            error = TypeError(
                &#34;The appdata_dir parameter must be of type string.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        if appdata_dir and not os.path.isdir(appdata_dir):
            _error = FileNotFoundError(
                &#34;The appdata_dir parameter must be an exising directory.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(_error)}&#34;)
            raise _error

        self._blocklist_lock = Lock()
        self._terminate = False

        self.sequential_block_handling = sequential_block_handling
        self.update_blockids_before_handling = update_blockids_before_handling

        self._blocks_listener = BlocksListener(
            self.blockchain_id, self._on_new_block_received
        )

        # if the user specified an appdata directory, use it
        if appdata_dir:
            self.appdata_dir = appdata_dir
        elif app_name:
            self.appdata_dir = os.path.join(
                walytis_beta_appdata_dir,
                self.blockchain_id,
                &#34;Apps&#34;,
                self.app_name,
            )
            # if appdata path doesn&#39;t exist
            # and we&#39;re not being used by a temporary app
            if not os.path.exists(self.appdata_dir):
                os.makedirs(self.appdata_dir)
        else:
            self.appdata_dir = &#34;&#34;
        if forget_appdata and os.path.exists(self.appdata_dir):
            shutil.rmtree(self.appdata_dir)
        self._load_blocks_list()
        if auto_load_missed_blocks:
            self.load_missed_blocks(N_STARTUP_BLOCKS)

    def add_block(
        self, content: bytearray | bytes, topics: list[str] | str | None = None,
        wait_until_handled: bool = True
    ) -&gt; Block:
        &#34;&#34;&#34;Add a new block to this blockchain.

        Args:
            content (bytearay): the content which the new block should have
            topics (list&lt;str&gt;): a list of topics this block belongs to
                    Topics allow blocks to be categorised by their application-
                    level function given the block ID only, without reading the
                    block content
        Returns:
            Block block: the newly created block
        &#34;&#34;&#34;
        if type(content) not in [bytearray, bytes]:
            raise TypeError(
                &#34;Content must be of type bytes or bytearray, not &#34;
                f&#34;{type(content)}&#34;
            )
        self._blocklist_lock.acquire()

        if topics == []:
            topics = self.blockchain_id
        try:
            block = create_block(self.blockchain_id, content, topics=topics)
        except BlockCreationError as error:
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            self._blocklist_lock.release()
            raise error

        # self._blocks.add_block_id(block.long_id)
        # self._save_blocks_list(True)
        self._blocklist_lock.release()
        if wait_until_handled:
            self._on_new_block_received(block)

            # wait for block received handler to finish for consistent behaviour
            while block.long_id not in self.get_block_ids():
                sleep(0.1)
                if self._terminate:
                    self._on_new_block_received(block, override_terminate=True)
                    break

        return block

    def get_blocks(self, reverse: bool = False) -&gt; Generator[BlockLazilyLoaded]:
        return self._blocks.get_blocks(reverse=reverse)

    def get_block_ids(self) -&gt; list[bytes]:
        return self._blocks.get_long_ids()

    def get_num_blocks(self) -&gt; int:
        return len(self._blocks)

    def has_block_id(self, block_id: bytes | bytearray) -&gt; bool:
        if isinstance(block_id, bytearray):
            block_id = bytes(block_id)
        return block_id in self._blocks

    def has_block(self, block: GenericBlock) -&gt; bool:
        return self.has_block_id(block.long_id)

    def get_block(self, id: bytearray | bytes) -&gt; Block:
        &#34;&#34;&#34;Get a block object from this blockchain given its block ID.

        Args:
            id (bytearray): the id of the block to look up
                            or if int: the index of the block to look up
        Returns:
            Block: a Block object containing all the requested block&#39;s data
        &#34;&#34;&#34;
        self._blocklist_lock.acquire()

        # if index is passed instead of block_id, get block_id from index
        if isinstance(id, int):
            try:
                id = self.get_block_ids()[id]
            except IndexError:
                self._blocklist_lock.release()
                message = (
                    &#34;Walytis_BetaAPI.Blockchain: Get Block from index: &#34;
                    &#34;Index out of range.&#34;
                )
                logger.error(message)
                raise IndexError(message)
        else:
            id_bytearray = bytearray(id)
            len_id = len(id_bytearray)
            if bytearray([0, 0, 0, 0]) not in id_bytearray:  # if a short ID was passed
                short_id = None
                for long_id in self.get_block_ids():
                    if bytearray(long_id)[:len_id] == id_bytearray:
                        short_id = long_id
                        break
                if not short_id:
                    raise BlockNotFoundError()
                id = bytes(short_id)
        if isinstance(id, bytearray):
            id = bytes(id)
        try:
            block = self._blocks[id]
            self._blocklist_lock.release()
            return block
        except KeyError:
            self._blocklist_lock.release()

            error = BlockNotFoundError(
                &#34;This block isn&#39;t recorded (by brenthy_api.Blockchain) as being &#34;
                &#34;part of this blockchain.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error

    def create_invitation(
        self, one_time: bool = True, shared: bool = False
    ) -&gt; str:
        &#34;&#34;&#34;Create a code which another node can use to join this blockchain.

        Args:
            one_time (bool): whether this code is non-reusable
            shared (bool): whether this invitation should be hosted by other
                    nodes who join this blockchain too, or just by this one
        Returns:
            str: a code that can be used by other nodes to join this blockchain
        &#34;&#34;&#34;
        return create_invitation(
            self.blockchain_id, one_time=one_time, shared=shared
        )

    def delete_invitation(self, invitation: str) -&gt; None:
        &#34;&#34;&#34;Delete an invitation from this blockchain.

        Args:
            invitation (str): the invitation to delete
        &#34;&#34;&#34;
        delete_invitation(self.blockchain_id, invitation)

    def get_invitations(self) -&gt; list[str]:
        &#34;&#34;&#34;Get a list of the invitations we&#39;re hositng for this blockchain.

        Returns:
            list: the invitations we&#39;re hosting for this blockchain,
                    as JSON strings
        &#34;&#34;&#34;
        return get_invitations(self.blockchain_id)

    def get_peers(self) -&gt; list[str]:
        &#34;&#34;&#34;Get the IPFS peer IDs of blockchain nodes who are currently online.

        Returns:
            list[str]: a list of IPFS peer IDs of the currently connected nodes
        &#34;&#34;&#34;
        return get_peers(self.blockchain_id)

    def get_blockchain_data(self) -&gt; str:
        &#34;&#34;&#34;Create a zip file of all this blockchain&#39;s data, returning its path.

        Returns:
            str: the path of the zip file created
        &#34;&#34;&#34;
        return get_blockchain_data(self.blockchain_id)

    def _run_block_received_handler(self, block: Block) -&gt; None:
        if not self.block_received_handler:
            return
        return_value = self.block_received_handler(block)
        if return_value is not None:
            raise ValueError(
                &#34;block_received_handler must return None, as it&#39;s meaningful &#34;
                &#34;usage is reserved for future use&#34;
            )

    def _on_new_block_received(
        self,
        block: Block,
        save_blocks_list: bool = True,
        already_locked: bool = False,
        override_terminate: bool = False,
        already_locked_block_received: bool = False,

    ) -&gt; None:
        &#34;&#34;&#34;Handle a newly received block.

        Gets called when this blockchain received a new block. Saves the block
        in our block list and calls the appropriate user-defined eventhandlers.

        Args:
            block (Block): the newly received block
            save_blocks_list (bool): whether or not to save our updated list
                        of blocks to appdata
            already_locked (bool): whether or not we&#39;ve already acquired the
                        lock for working with the blocks list
            override_terminate (bool): whether to process block even if this
                        Blockchain object is terminating
        &#34;&#34;&#34;
        if self._terminate and not override_terminate:
            return
        if not already_locked_block_received:
            self._block_received_handler_lock.acquire()
        # if not already_locked:
        #     self._blocklist_lock.acquire()
        short_ids = self._blocks.get_short_ids()
        if bytes(block.long_id) not in self._blocks:
            for parent in block.parents:
                if bytes(parent) not in short_ids:
                    self._on_new_block_received(
                        get_block(self.blockchain_id, parent),
                        save_blocks_list=save_blocks_list,
                        # already_locked=True
                        already_locked=already_locked,
                        already_locked_block_received=True
                    )
            try:
                if self.update_blockids_before_handling:
                    self._update_blocks_list(block, already_locked=True)

                # call user&#39;s block_received_handler
                # only if the block isn&#39;t a genesis block
                if block.topics == [&#34;genesis&#34;]:
                    logger.info(&#34;WAPI: Received Genesis Block!&#34;)
                elif self.block_received_handler:  # it&#39;s a normal block
                    if self.sequential_block_handling:
                        self._run_block_received_handler(block)
                    else:
                        Thread(
                            target=self._run_block_received_handler,
                            args=(block,),
                            name=f&#34;WAPI-{self.name}-block_received_handler&#34;,
                        ).start()
                if not self.update_blockids_before_handling:
                    self._update_blocks_list(block, already_locked=True)

            except Exception as e:
                logger.error(f&#34;WAPI: Blockchain._on_new_block_received: {e}&#34;)
        if not already_locked_block_received:
            self._block_received_handler_lock.release()

    def _update_blocks_list(
        self,
        block: Block,
        save_blocks_list: bool = True,
        already_locked: bool = False
    ) -&gt; None:
        if not already_locked:
            self._blocklist_lock.acquire()
        self._blocks.add_block_id(block.long_id)
        if save_blocks_list:
            self._save_blocks_list(already_locked=True)

        if not already_locked:
            self._blocklist_lock.release()

    def _save_blocks_list(self, already_locked: bool = False) -&gt; None:
        &#34;&#34;&#34;Save our list of known/processed block IDs to an appdata file.&#34;&#34;&#34;
        # don&#39;t save any appdata if we&#39;re being used by a temporary app
        if not self.appdata_dir:
            return
        if not already_locked:
            self._blocklist_lock.acquire()

        with open(
            os.path.join(self.appdata_dir, &#34;blocks_list&#34;), &#34;w+&#34;
        ) as filewriter:
            filewriter.writelines(
                [
                    bytes_to_string(block_id) + &#34;\n&#34;
                    for block_id in self.get_block_ids()
                ]
            )
        if not already_locked:
            self._blocklist_lock.release()

    def load_missed_blocks(self, amount: int) -&gt; None:
        &#34;&#34;&#34;Get recent blocks.

        Ask the Blockchain for recent blocks on this topic that might have been
        received while this program was offline. Any of these missed blocks
        will trigger the self.block_received_handler event handler.

        Args:
            amount (int): the number of blocks to load
        &#34;&#34;&#34;
        # self._blocklist_lock.acquire()
        logger.info(amount)
        latest_blocks = get_latest_blocks(
            self.blockchain_id, amount=amount, long_ids=True)
        if not latest_blocks:
            # self._blocklist_lock.release()
            error = NotSupposedToHappenError(
                &#34;Got no latest blocks from blockchain. &#34;
                &#34;This is probably due to a bug in walytis_api.&#34;
            )
            logger.error(f&#34;WAPI: {function_name()}: {str(error)}&#34;)
            raise error
        count = 0
        for block_id in latest_blocks:
            if self._terminate:
                # self._blocklist_lock.release()
                return

            if bytes(block_id) not in self.get_block_ids():
                try:
                    block = get_block(self.blockchain_id, block_id)
                    self._on_new_block_received(
                        block,
                        save_blocks_list=False,
                        # already_locked=True
                    )
                except Exception as e:
                    logger.error(
                        f&#34; Blockchain.load_missed_blocks: {e}&#34;
                    )
            else:
                count += 1

        self._save_blocks_list(
            # already_locked=True
        )
        # self._blocklist_lock.release()

    def _load_blocks_list(self) -&gt; None:
        &#34;&#34;&#34;Load our list of known/processed block IDs from an appdata file.&#34;&#34;&#34;
        if not self.appdata_dir:
            return

        self._blocklist_lock.acquire()

        if os.path.exists(os.path.join(self.appdata_dir, &#34;blocks_list&#34;)):
            block_ids = []
            with open(
                os.path.join(self.appdata_dir, &#34;blocks_list&#34;), &#34;r&#34;
            ) as filereader:
                for line in filereader.readlines():
                    block_ids.append(string_to_bytes(line[:-1]))

            # AppData migration from storing short IDs to long_ids
            # for BACKWARDS COMPATIBILITY
            if bytearray([0, 0, 0, 0]) not in bytearray(block_ids[0]) or bytearray([0, 0, 0, 0]) not in bytearray(block_ids[-1]):
                print(&#34;Migrating...&#34;)
                block_long_ids = dict([
                    (bytes(short_from_long_id(long_id)), long_id)
                    for long_id in get_latest_blocks(self.blockchain_id, long_ids=True)
                ])
                block_ids = [block_long_ids[bytes(short_id)]
                             for short_id in block_ids]

            self._blocks = BlocksList.from_block_ids(
                block_ids, BlockLazilyLoaded)
        self._blocklist_lock.release()

    @property
    def block_ids(self) -&gt; list[bytearray]:
        &#34;&#34;&#34;Get a list of this blockchain&#39;s blocks&#39; short IDs.

        Retained for backwards-compatibilty.
        &#34;&#34;&#34;
        print(
            &#34;`Blockchain.block_ids` has been deprecated because it returns &#34;
            &#34;block&#39;s short IDs. Use `Blockchain.get_block_ids()` instead, &#34;
            &#34;which returns their long IDs.&#34;
        )
        return self._blocks.get_short_ids()

    def terminate(self) -&gt; None:
        &#34;&#34;&#34;Clean up all resources this object uses.&#34;&#34;&#34;
        self._terminate = True
        logger.debug(&#34;Terminating...&#34;)
        if self._blocks_listener:
            self._blocks_listener.terminate()
        logger.debug(&#34;Terminated!&#34;)

    def __del__(self) -&gt; None:
        &#34;&#34;&#34;Clean up all resources this object uses.&#34;&#34;&#34;
        self.terminate()

    def delete(self) -&gt; None:
        &#34;&#34;&#34;Stop our participation in this blockchain.

        Locally deletes all data we have stored for it.
        &#34;&#34;&#34;
        self.terminate()
        delete_blockchain(self.blockchain_id)

    @staticmethod
    def create(
        blockchain_name: str = &#34;&#34;,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ) -&gt; &#39;Blockchain&#39;:
        &#34;&#34;&#34;Create and run a new blockchain.

        Args:
            blockchain_name (str):
                blockchain&#39;s local name: a human-readable label
                to ease recognition when manually interacting with WalytisAPI.
                Note: A blockchain&#39;s name only exists in the scope of a single
                node, meaning it is not guaranteed to be globally unique.
                Applications should use a blockchain&#39;s ID (attribute &#39;id&#39;) as
                its identifier, not the blockchain_name.
            block_received_handler (Callable):
                A function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this handler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                    blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received

        Returns:
            Blockchain: a Blockchain object representing the created blockchain
        &#34;&#34;&#34;
        blockchain_id = create_blockchain(blockchain_name=blockchain_name)
        return Blockchain(
            blockchain_id,
            block_received_handler=block_received_handler,
            app_name=app_name,
            appdata_dir=appdata_dir,
            auto_load_missed_blocks=auto_load_missed_blocks,
            forget_appdata=forget_appdata,
            sequential_block_handling=sequential_block_handling,
            update_blockids_before_handling=update_blockids_before_handling,
        )

    @staticmethod
    def join(
        invitation: str,
        blockchain_name: str = &#34;&#34;,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ) -&gt; &#39;Blockchain&#39;:
        &#34;&#34;&#34;Join a blockchain using an invitation generated by another node.

        Args:
            invitation (str): the invitation generated by a blockchain member
            blockchain_name (str):
                blockchain&#39;s local name: a human-readable label
                to ease recognition when manually interacting with WalytisAPI.
                Note: A blockchain&#39;s name only exists in the scope of a single
                node, meaning it is not guaranteed to be globally unique.
                Applications should use a blockchain&#39;s ID (attribute &#39;id&#39;) as
                its identifier, not the blockchain_name.
            block_received_handler (Callable):
                A function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this handler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                    blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received

        Returns:
            Blockchain: a Blockchain object representing the joined blockchain
        &#34;&#34;&#34;
        blockchain_id = join_blockchain(
            invitation, blockchain_name=blockchain_name
        )
        return Blockchain(
            blockchain_id,
            block_received_handler=block_received_handler,
            app_name=app_name,
            appdata_dir=appdata_dir,
            auto_load_missed_blocks=auto_load_missed_blocks,
            forget_appdata=forget_appdata,
            sequential_block_handling=sequential_block_handling,
            update_blockids_before_handling=update_blockids_before_handling,
        )

    @staticmethod
    def from_blockchain_id(
        blockchain_id: str,
        block_received_handler: Callable[[Block], None] | None = None,
        app_name: str = &#34;&#34;,
        appdata_dir: str = &#34;&#34;,
        auto_load_missed_blocks: bool = True,
        forget_appdata: bool = False,
        sequential_block_handling: bool = True,
        update_blockids_before_handling: bool = False,
    ) -&gt; &#39;Blockchain&#39;:
        &#34;&#34;&#34;Create an object to represent a Walytis blockchain.

        Args:
            blockchain_id (str): the id or name of the blockchain
            block_received_handler (Callable): function to be called every
                time a new block is received on this blockchain.
                This function should not have a long execution time because
                this class waits for its execution to finish before saving
                the received block in its list of processed blocks.
                If this eventhandler raises an exception, it will be called
                with the same block at a later stage.
                The same block is never passed to this handler twice, and
                no child block will ever be passed to this function before
                its parent block.
            app_name (str): the unique name of this application, to distinguish
                between different applications that use the same blockchain
                for appdata management
            appdata_dir (str): the directory in which to save data on which
                blocks this application has processed for this blockchain
            auto_load_missed_blocks (bool): whether or not to automatically get
                and process the blocks received by the blockchain while
                this application was offline.
            forget_appdata (bool): whether or not to ignore and overwrite any
                existing records of which blocks applications with the
                providede `app_name` have processed
            sequential_block_handling (bool): if True, the provided block-
                received handler will be executed on the main thread, and
                the handler will only be executed for the next block
                after the handler for the last block executes witout
                error.
                If set to False, the block-received handler will always be
                started on a new thread, meaning it is possible for
                multiple calls of the handler to be running in parallel
                for different blocks.
            update_blockids_before_handling (bool): whether or not the
                `blocks` attribute should be updated before running
                `block_received_handler` when a new block is received
        &#34;&#34;&#34;
        return Blockchain(
            blockchain_id=blockchain_id,
            block_received_handler=block_received_handler,
            app_name=app_name,
            appdata_dir=appdata_dir,
            auto_load_missed_blocks=auto_load_missed_blocks,
            forget_appdata=forget_appdata,
            sequential_block_handling=sequential_block_handling,
            update_blockids_before_handling=update_blockids_before_handling,
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="walytis_beta_api.blockchain_model.Blockchain.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>blockchain_name: str = '', block_received_handler: Optional[Callable[[walytis_beta_tools.block_model.Block], None]] = None, app_name: str = '', appdata_dir: str = '', auto_load_missed_blocks: bool = True, forget_appdata: bool = False, sequential_block_handling: bool = True, update_blockids_before_handling: bool = False) ‑> <a title="walytis_beta_api.blockchain_model.Blockchain" href="#walytis_beta_api.blockchain_model.Blockchain">Blockchain</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create and run a new blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt>blockchain_name (str):</dt>
<dt>blockchain's local name: a human-readable label</dt>
<dt>to ease recognition when manually interacting with WalytisAPI.</dt>
<dt>Note: A blockchain's name only exists in the scope of a single</dt>
<dt>node, meaning it is not guaranteed to be globally unique.</dt>
<dt>Applications should use a blockchain's ID (attribute 'id') as</dt>
<dt>its identifier, not the blockchain_name.</dt>
<dt>block_received_handler (Callable):</dt>
<dt>A function to be called every</dt>
<dt>time a new block is received on this blockchain.</dt>
<dt>This function should not have a long execution time because</dt>
<dt>this class waits for its execution to finish before saving</dt>
<dt>the received block in its list of processed blocks.</dt>
<dt>If this handler raises an exception, it will be called</dt>
<dt>with the same block at a later stage.</dt>
<dt>The same block is never passed to this handler twice, and</dt>
<dt>no child block will ever be passed to this function before</dt>
<dt>its parent block.</dt>
<dt><strong><code>app_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the unique name of this application, to distinguish
between different applications that use the same blockchain
for appdata management</dd>
<dt><strong><code>appdata_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the directory in which to save data on which
blocks this application has processed for this blockchain</dd>
<dt><strong><code>auto_load_missed_blocks</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to automatically get
and process the blocks received by the blockchain while
this application was offline.</dd>
<dt><strong><code>forget_appdata</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to ignore and overwrite any
existing records of which blocks applications with the
providede <code>app_name</code> have processed</dd>
<dt><strong><code>sequential_block_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the provided block-
received handler will be executed on the main thread, and
the handler will only be executed for the next block
after the handler for the last block executes witout
error.
If set to False, the block-received handler will always be
started on a new thread, meaning it is possible for
multiple calls of the handler to be running in parallel
for different blocks.</dd>
<dt><strong><code>update_blockids_before_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not the
<code>blocks</code> attribute should be updated before running
<code>block_received_handler</code> when a new block is received</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="walytis_beta_api.blockchain_model.Blockchain" href="#walytis_beta_api.blockchain_model.Blockchain">Blockchain</a></code></dt>
<dd>a Blockchain object representing the created blockchain</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>invitation: str, blockchain_name: str = '', block_received_handler: Optional[Callable[[walytis_beta_tools.block_model.Block], None]] = None, app_name: str = '', appdata_dir: str = '', auto_load_missed_blocks: bool = True, forget_appdata: bool = False, sequential_block_handling: bool = True, update_blockids_before_handling: bool = False) ‑> <a title="walytis_beta_api.blockchain_model.Blockchain" href="#walytis_beta_api.blockchain_model.Blockchain">Blockchain</a></span>
</code></dt>
<dd>
<div class="desc"><p>Join a blockchain using an invitation generated by another node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>invitation</code></strong> :&ensp;<code>str</code></dt>
<dd>the invitation generated by a blockchain member</dd>
<dt>blockchain_name (str):</dt>
<dt>blockchain's local name: a human-readable label</dt>
<dt>to ease recognition when manually interacting with WalytisAPI.</dt>
<dt>Note: A blockchain's name only exists in the scope of a single</dt>
<dt>node, meaning it is not guaranteed to be globally unique.</dt>
<dt>Applications should use a blockchain's ID (attribute 'id') as</dt>
<dt>its identifier, not the blockchain_name.</dt>
<dt>block_received_handler (Callable):</dt>
<dt>A function to be called every</dt>
<dt>time a new block is received on this blockchain.</dt>
<dt>This function should not have a long execution time because</dt>
<dt>this class waits for its execution to finish before saving</dt>
<dt>the received block in its list of processed blocks.</dt>
<dt>If this handler raises an exception, it will be called</dt>
<dt>with the same block at a later stage.</dt>
<dt>The same block is never passed to this handler twice, and</dt>
<dt>no child block will ever be passed to this function before</dt>
<dt>its parent block.</dt>
<dt><strong><code>app_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the unique name of this application, to distinguish
between different applications that use the same blockchain
for appdata management</dd>
<dt><strong><code>appdata_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the directory in which to save data on which
blocks this application has processed for this blockchain</dd>
<dt><strong><code>auto_load_missed_blocks</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to automatically get
and process the blocks received by the blockchain while
this application was offline.</dd>
<dt><strong><code>forget_appdata</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to ignore and overwrite any
existing records of which blocks applications with the
providede <code>app_name</code> have processed</dd>
<dt><strong><code>sequential_block_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the provided block-
received handler will be executed on the main thread, and
the handler will only be executed for the next block
after the handler for the last block executes witout
error.
If set to False, the block-received handler will always be
started on a new thread, meaning it is possible for
multiple calls of the handler to be running in parallel
for different blocks.</dd>
<dt><strong><code>update_blockids_before_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not the
<code>blocks</code> attribute should be updated before running
<code>block_received_handler</code> when a new block is received</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="walytis_beta_api.blockchain_model.Blockchain" href="#walytis_beta_api.blockchain_model.Blockchain">Blockchain</a></code></dt>
<dd>a Blockchain object representing the joined blockchain</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.from_blockchain_id"><code class="name flex">
<span>def <span class="ident">from_blockchain_id</span></span>(<span>blockchain_id: str, block_received_handler: Optional[Callable[[walytis_beta_tools.block_model.Block], None]] = None, app_name: str = '', appdata_dir: str = '', auto_load_missed_blocks: bool = True, forget_appdata: bool = False, sequential_block_handling: bool = True, update_blockids_before_handling: bool = False) ‑> <a title="walytis_beta_api.blockchain_model.Blockchain" href="#walytis_beta_api.blockchain_model.Blockchain">Blockchain</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an object to represent a Walytis blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blockchain_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the id or name of the blockchain</dd>
<dt><strong><code>block_received_handler</code></strong> :&ensp;<code>Callable</code></dt>
<dd>function to be called every
time a new block is received on this blockchain.
This function should not have a long execution time because
this class waits for its execution to finish before saving
the received block in its list of processed blocks.
If this eventhandler raises an exception, it will be called
with the same block at a later stage.
The same block is never passed to this handler twice, and
no child block will ever be passed to this function before
its parent block.</dd>
<dt><strong><code>app_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the unique name of this application, to distinguish
between different applications that use the same blockchain
for appdata management</dd>
<dt><strong><code>appdata_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the directory in which to save data on which
blocks this application has processed for this blockchain</dd>
<dt><strong><code>auto_load_missed_blocks</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to automatically get
and process the blocks received by the blockchain while
this application was offline.</dd>
<dt><strong><code>forget_appdata</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to ignore and overwrite any
existing records of which blocks applications with the
providede <code>app_name</code> have processed</dd>
<dt><strong><code>sequential_block_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the provided block-
received handler will be executed on the main thread, and
the handler will only be executed for the next block
after the handler for the last block executes witout
error.
If set to False, the block-received handler will always be
started on a new thread, meaning it is possible for
multiple calls of the handler to be running in parallel
for different blocks.</dd>
<dt><strong><code>update_blockids_before_handling</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not the
<code>blocks</code> attribute should be updated before running
<code>block_received_handler</code> when a new block is received</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="walytis_beta_api.blockchain_model.Blockchain.block_ids"><code class="name">var <span class="ident">block_ids</span> : list[bytearray]</code></dt>
<dd>
<div class="desc"><p>Get a list of this blockchain's blocks' short IDs.</p>
<p>Retained for backwards-compatibilty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def block_ids(self) -&gt; list[bytearray]:
    &#34;&#34;&#34;Get a list of this blockchain&#39;s blocks&#39; short IDs.

    Retained for backwards-compatibilty.
    &#34;&#34;&#34;
    print(
        &#34;`Blockchain.block_ids` has been deprecated because it returns &#34;
        &#34;block&#39;s short IDs. Use `Blockchain.get_block_ids()` instead, &#34;
        &#34;which returns their long IDs.&#34;
    )
    return self._blocks.get_short_ids()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="walytis_beta_api.blockchain_model.Blockchain.add_block"><code class="name flex">
<span>def <span class="ident">add_block</span></span>(<span>self, content: bytearray | bytes, topics: list[str] | str | None = None, wait_until_handled: bool = True) ‑> walytis_beta_tools.block_model.Block</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new block to this blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code>bytearay</code></dt>
<dd>the content which the new block should have</dd>
</dl>
<p>topics (list<str>): a list of topics this block belongs to
Topics allow blocks to be categorised by their application-
level function given the block ID only, without reading the
block content</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Block block</code></dt>
<dd>the newly created block</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.get_blocks"><code class="name flex">
<span>def <span class="ident">get_blocks</span></span>(<span>self, reverse: bool = False) ‑> collections.abc.Generator[walytis_beta_tools._experimental.block_lazy_loading.BlockLazilyLoaded]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.get_block_ids"><code class="name flex">
<span>def <span class="ident">get_block_ids</span></span>(<span>self) ‑> list[bytes]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.get_num_blocks"><code class="name flex">
<span>def <span class="ident">get_num_blocks</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.has_block_id"><code class="name flex">
<span>def <span class="ident">has_block_id</span></span>(<span>self, block_id: bytearray | bytes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.has_block"><code class="name flex">
<span>def <span class="ident">has_block</span></span>(<span>self, block: walytis_beta_tools._experimental.generic_block.GenericBlock) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.get_block"><code class="name flex">
<span>def <span class="ident">get_block</span></span>(<span>self, id: bytearray | bytes) ‑> walytis_beta_tools.block_model.Block</span>
</code></dt>
<dd>
<div class="desc"><p>Get a block object from this blockchain given its block ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>bytearray</code></dt>
<dd>the id of the block to look up
or if int: the index of the block to look up</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Block</code></dt>
<dd>a Block object containing all the requested block's data</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.create_invitation"><code class="name flex">
<span>def <span class="ident">create_invitation</span></span>(<span>self, one_time: bool = True, shared: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a code which another node can use to join this blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>one_time</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether this code is non-reusable</dd>
<dt><strong><code>shared</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether this invitation should be hosted by other
nodes who join this blockchain too, or just by this one</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>a code that can be used by other nodes to join this blockchain</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.delete_invitation"><code class="name flex">
<span>def <span class="ident">delete_invitation</span></span>(<span>self, invitation: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an invitation from this blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>invitation</code></strong> :&ensp;<code>str</code></dt>
<dd>the invitation to delete</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.get_invitations"><code class="name flex">
<span>def <span class="ident">get_invitations</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of the invitations we're hositng for this blockchain.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>the invitations we're hosting for this blockchain,
as JSON strings</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.get_peers"><code class="name flex">
<span>def <span class="ident">get_peers</span></span>(<span>self) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the IPFS peer IDs of blockchain nodes who are currently online.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>a list of IPFS peer IDs of the currently connected nodes</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.get_blockchain_data"><code class="name flex">
<span>def <span class="ident">get_blockchain_data</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a zip file of all this blockchain's data, returning its path.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the path of the zip file created</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.load_missed_blocks"><code class="name flex">
<span>def <span class="ident">load_missed_blocks</span></span>(<span>self, amount: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Get recent blocks.</p>
<p>Ask the Blockchain for recent blocks on this topic that might have been
received while this program was offline. Any of these missed blocks
will trigger the self.block_received_handler event handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of blocks to load</dd>
</dl></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.terminate"><code class="name flex">
<span>def <span class="ident">terminate</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Clean up all resources this object uses.</p></div>
</dd>
<dt id="walytis_beta_api.blockchain_model.Blockchain.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Stop our participation in this blockchain.</p>
<p>Locally deletes all data we have stored for it.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="walytis_beta_api" href="index.html">walytis_beta_api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="walytis_beta_api.blockchain_model.set_appdata_dir" href="#walytis_beta_api.blockchain_model.set_appdata_dir">set_appdata_dir</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.get_appdata_dir" href="#walytis_beta_api.blockchain_model.get_appdata_dir">get_appdata_dir</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.get_walytis_appdata_dir" href="#walytis_beta_api.blockchain_model.get_walytis_appdata_dir">get_walytis_appdata_dir</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="walytis_beta_api.blockchain_model.Blockchain" href="#walytis_beta_api.blockchain_model.Blockchain">Blockchain</a></code></h4>
<ul class="two-column">
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.create" href="#walytis_beta_api.blockchain_model.Blockchain.create">create</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.join" href="#walytis_beta_api.blockchain_model.Blockchain.join">join</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.from_blockchain_id" href="#walytis_beta_api.blockchain_model.Blockchain.from_blockchain_id">from_blockchain_id</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.add_block" href="#walytis_beta_api.blockchain_model.Blockchain.add_block">add_block</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.get_blocks" href="#walytis_beta_api.blockchain_model.Blockchain.get_blocks">get_blocks</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.get_block_ids" href="#walytis_beta_api.blockchain_model.Blockchain.get_block_ids">get_block_ids</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.get_num_blocks" href="#walytis_beta_api.blockchain_model.Blockchain.get_num_blocks">get_num_blocks</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.has_block_id" href="#walytis_beta_api.blockchain_model.Blockchain.has_block_id">has_block_id</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.has_block" href="#walytis_beta_api.blockchain_model.Blockchain.has_block">has_block</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.get_block" href="#walytis_beta_api.blockchain_model.Blockchain.get_block">get_block</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.create_invitation" href="#walytis_beta_api.blockchain_model.Blockchain.create_invitation">create_invitation</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.delete_invitation" href="#walytis_beta_api.blockchain_model.Blockchain.delete_invitation">delete_invitation</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.get_invitations" href="#walytis_beta_api.blockchain_model.Blockchain.get_invitations">get_invitations</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.get_peers" href="#walytis_beta_api.blockchain_model.Blockchain.get_peers">get_peers</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.get_blockchain_data" href="#walytis_beta_api.blockchain_model.Blockchain.get_blockchain_data">get_blockchain_data</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.load_missed_blocks" href="#walytis_beta_api.blockchain_model.Blockchain.load_missed_blocks">load_missed_blocks</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.terminate" href="#walytis_beta_api.blockchain_model.Blockchain.terminate">terminate</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.delete" href="#walytis_beta_api.blockchain_model.Blockchain.delete">delete</a></code></li>
<li><code><a title="walytis_beta_api.blockchain_model.Blockchain.block_ids" href="#walytis_beta_api.blockchain_model.Blockchain.block_ids">block_ids</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
